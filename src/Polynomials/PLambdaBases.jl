# The theory and notations used in this file are documented in detail in the
# Bernstein bases algorithms Developper notes of the official documentation.

#######################
# PLambdaIndices type #
#######################

# Do print some PLambdaIndices generated by PΛ_bubbles(r,k,D) in REPL before
# reading this...

# All types and fields "XX" below should be understood as "Indices_For_XX"

# One bubble function:
#               ω_w  =      (  w,             α, α_id,           J,   sub_J_ids,  sup_α_ids )
const BubbleFunction = Tuple{Int, BernsteinTerm,  Int, Vector{Int}, Vector{Int}, Vector{Int}}

# One bubble space associated to the d-dimensional face F
# bubble_d_F =      (          F,    F_bubble_functions )
const Bubble = Tuple{Vector{Int}, Vector{BubbleFunction}}

struct PLambdaIndices
  # An objectid is stored here to keep track of what's inside and perform a
  # sanity check when reusing the indices elsewhere:
  #     identity = objectid( (r,k,D,:P,false) )
  # for a PᵣΛᵏ(△ᴰ) basis indices with vector-proxied components.
  identity::UInt

  # bubble indices given by P(m)Λ_bubbles (can be filtered and renumbered to select subset of bubbles)
  # The BubbleFunction[1] "w" MUST be in increasing order when iterating over bubbles and bubble_functions
  bubbles::Vector{Bubble}

  # Indices for the components of a basis k-form or its vector calculus proxy,
  #                       (I_id,           I, sgnIcomp), see _basis_forms_components .
  components::Vector{Tuple{ Int, Vector{Int},      Int}}

  # Components "I" of the exterior derivative of a basis polynomial form
  # ext_deriv_components::Vector{Component}
end

function _check_PΛ_indices(r,k,D,P,DG_style, indices::PLambdaIndices)
  @check P==:P || P==:P⁻
  # Changing one of those requires re-computing all fields of PLambdaIndices,
  # otherwise wrong result or segfault due to @inbounds in evaluating functions
  # are expected
  @assert objectid( (r,k,D,P,DG_style) ) == indices.identity
  @check begin
    ordered_bf_ids = [ bubfun[1] for bub in indices.bubbles for bubfun in bub[2] ]
    C = length(ordered_bf_ids)
    ordered_bf_ids == 1:C
  end "Invalid PLambdaIndices: bubble functions are not numbered from 1 to length(b) in the bubble indices"
end

"""
    _last_bubble_function_index(ids::PLambdaIndices)

The index of the last bubble function in `ids`, that is also the number of basis
polynomial defined by `ids`, and cardinal of the owning basis.
"""
function _last_bubble_function_index(ids::PLambdaIndices)
  isempty(ids.bubbles) && return 0
  return ids.bubbles[end][2][end][1]
end

function Base.show(io::IO, ::MIME"text/plain", indices::PLambdaIndices)
  if isempty(indices.bubbles)
    print(io,"Empty PΛ basis indices")
    return
  end

  α = indices.bubbles[1][2][1][2]
  J = indices.bubbles[1][2][1][4]
  I = indices.components[1][2]

  r = sum(α)+length(J)-length(I)
  k = length(I)
  D = length(α)-1
  is_Pm = r != sum(α)
  println(io,"PᵣΛᵏ(△ᴰ) basis indices, r=$r k=$k D=$D")

  println()
  println(io,"Basis polynomial components")
  println(io,"\tI_id\t I\t I_sgn")
  for (I_id, I, I_sgn) in indices.components
    println(io,"\t$I_id\t $(join(I))\t $I_sgn")
  end

  println()
  println(io,"\tw \tα \tα_id \tJ",  is_Pm ? "\tsub_J_ids \tsup_α_ids" : "")
  for (F, F_bubble) in indices.bubbles
    isempty(F_bubble) && continue

    println(io,"Bubble of face F=$(join(F))")
    for (w, α, α_id, J, sub_J_ids, sup_α_ids) in F_bubble
      println(io,"\t$w \t$(join(α)) \t$α_id \t$(join(J)) \t$(join(sub_J_ids,",")) \t\t$(join(sup_α_ids,","))")
    end
  end
  println()
  println(io,"PᵣΛᵏ(△ᴰ) basis indices, r=$r k=$k D=$D")
end


#####################################
# PmLambdaBasis nD polynomial bases #
#####################################

"""
    PmLambdaBasis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces P⁻`ᵣ`Λ`ᴷ` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator ⋆ and the sharp map ♯, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L` is binomial(`D`,`k`),
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

The number of basis polynomials is binomial(`r`+`k`-1,`k`)*binomial(`D`+`r`,`D`-`k`) if no filtered bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct PmLambdaBasis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  m::SVector{LN,V}
  _indices::PLambdaIndices

  function PmLambdaBasis{D}(::Type{T}, r, k, vertices=nothing;
                            diff_geo_calculus_style=false, indices=nothing) where {D,T}

    @check T<:Real "T needs to be <:Real since represents the scalar type, got $T"
    @check k in 0:D "The form order k must be in 0:D, got $k"
    @check r > 0    "The polynomial order r must be positive, got $r"
    if !isnothing(vertices)
      @check length(vertices) == D+1 "$D+1 vertices are required to define a $D-dim simplex, got $(length(vertices))"
      @check eltype(vertices) <: Point{D} "Vertices should be of type <:Point{$D}, got $(eltype(vertices))"
    end

    indices = _generate_or_check_PmΛ_indices(r,k,D,diff_geo_calculus_style,indices)

    L = binomial(D,k) # Number of components of a basis form

    if diff_geo_calculus_style
      @notimplemented
    else
      (D>3 && ( 1 < k < D-1)) && @unreachable "Vector calculus proxy of differential form bases not available for D=$D and k=$k"
      V = VectorValue{L,T}
    end

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    LN = binomial(D+1,k) # Number of k-faces J of a D-dimensional tetrahedron
    m = zero(MVector{LN,V})
    _compute_PmΛ_basis_coefficients!(m,Val(k),D,b,vertices,indices)

    if isone(L) && !diff_geo_calculus_style
      V = T
      m = reinterpret(T, m)
    end

    new{D,V,LN,B}(r,k,b,m,indices)
  end
end

"""
    PmLambdaBasis(::Val{D}, T, r, k, vertices=nothing; indices=nothing)

Constructors for [`PmLambdaBasis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The `indices::PLambdaIndices` may be provided to avoid allocations or filter the bubbles.
"""
function PmLambdaBasis(::Val{D},::Type{T},r,k,vertices=nothing;
                       diff_geo_calculus_style=false, indices=nothing) where {D,T}

  PmLambdaBasis{D}(T,r,k,vertices; diff_geo_calculus_style, indices)
end

"""
    _DG_calculus_style(::V) = false

Temporary API to signal that the coefficient of `V`-valued polynomial forms
should be transformed into classic vector calulus components using Hodge star
operator.
"""
_DG_calculus_style(::V) where V = false

get_FEEC_poly_degree(b::PmLambdaBasis) = b.r
get_FEEC_form_degree(b::PmLambdaBasis) = b.k
get_FEEC_family(::PmLambdaBasis) = :P⁻

Base.size(b::PmLambdaBasis) = (_last_bubble_function_index(b._indices), )

####################################
# PLambdaBasis nD polynomial bases #
####################################

"""
    PLambdaBasis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces P`ᵣ`Λ`ᴷ` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator ⋆ and the sharp map ♯, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L=binomial(D,k)`,
- `C` is the number of basis polynomials,
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

`C` = binomial(`r`+`k`,`k`)*binomial(`D`+`r`,`D`-`k`) if no custom bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct PLambdaBasis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  Ψ::SVector{C,V}
  _indices::PLambdaIndices

  function PLambdaBasis{D}(::Type{T}, r, k, vertices=nothing;
                           diff_geo_calculus_style=false, indices=nothing) where {D,T}

    @check T<:Real "T needs to be <:Real since represents the scalar type, got $T"
    @check k in 0:D "The form order k must be in 0:D, got $k"
    @check r > 0    "The polynomial order r must be positive, got $r"
    if !isnothing(vertices)
      @check length(vertices) == D+1 "$D+1 vertices are required to define a $D-dim simplex, got $(length(vertices))"
      @check eltype(vertices) <: Point{D} "Vertices should be of type <:Point{$D}, got $(eltype(vertices))"
    end

    indices = _generate_or_check_PΛ_indices(r,k,D,diff_geo_calculus_style,indices)

    L = binomial(D,k) # Number of components of a basis form
    C = _last_bubble_function_index(indices) # Cardinal of the basis

    if diff_geo_calculus_style
      @notimplemented
    else
      (D>3 && ( 1 < k < D-1)) && @unreachable "Vector calculus proxy of differential form bases not available for D=$D and k=$k"
      V = VectorValue{L,T}
    end

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    Ψ = zero(MVector{C,V})
    _compute_PΛ_basis_form_coefficient!(Ψ,r,k,Val(D),b,vertices,indices)

    if isone(L) && !diff_geo_calculus_style
      V = T
      Ψ = reinterpret(T, Ψ)
    end

    new{D,V,C,B}(r,k,b,Ψ,indices)
  end
end

"""
    PLambdaBasis(::Val{D}, T, r, k, vertices=nothing; indices=nothing)

Constructors for [`PLambdaBasis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The `indices::PLambdaIndices` may be provided to avoid allocations or filter the bubbles.
"""
function PLambdaBasis(::Val{D},::Type{T},r,k,vertices=nothing;
                      diff_geo_calculus_style=false, indices=nothing) where {D,T}
  PLambdaBasis{D}(T,r,k,vertices; diff_geo_calculus_style, indices)
end

get_FEEC_poly_degree(b::PLambdaBasis) = b.r
get_FEEC_form_degree(b::PLambdaBasis) = b.k
get_FEEC_family(::PLambdaBasis) = :P

Base.size(::PLambdaBasis{D,V,C}) where {D,V,C} = (C, )


##########################
# Common Implementation  #
##########################

const PΛBases = Union{PmLambdaBasis, PLambdaBasis}

"""
    get_bubbles(b::PmLambdaBasis)
    get_bubbles(b::PLambdaBasis)

Get the iterator over the bubble spaces in the geometric decomposition of `b`,
typically generated by [`PmΛ_bubbles`](@ref) or [`PΛ_bubbles`](@ref).

They can be vizualized using [`print_indices(b)`](@ref print_indices).
"""
get_bubbles(b::PΛBases) = b._indices.bubbles
get_order(b::PΛBases) = get_FEEC_poly_degree(b)
print_indices(b::PΛBases) = println(b._indices)
_get_cart_to_bary_matrix(b::PΛBases) = b.scalar_bernstein_basis.cart_to_bary_matrix

function _return_cache(b::PΛBases,x,::Type{G},::Val{N_deriv}) where {G,N_deriv}
  T = eltype(G)
  np = length(x)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)

  r = CachedArray(zeros(G,(np,ndof)))
  # Cache for all scalar nD-Bernstein polynomials Bα
  cB = CachedVector(zeros(T,ndof_bernstein))
  # Cache for derivatives of Bα (∇Bα or HBα)
  if N_deriv > 0
    DB = T
    xi = testitem(x)
    for _ in 1:N_deriv
      DB = gradient_type(DB,xi)
    end
    # Cache for N_deriv's derivatives all of scalar nD-Bernstein polynomials
    t = (( nothing for _ in 2:N_deriv)..., CachedArray(zeros(DB,(1,ndof_bernstein))))
    s = MArray{Tuple{size(DB)...},T}(undef)
  else
    t = ()
    s = nothing
  end
  (r, s, cB, t...)
end

function _setsize!(b::PΛBases, np, ω, t...)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)
  setsize!(ω,(np,ndof))
  setsize!(t[1],(ndof_bernstein,)) # this is cB
  if length(t) > 1
    setsize!(t[end],(1,ndof_bernstein)) # this is ∇B or HB
  end
end

function _get_static_parameters(b::PΛBases)
  r = get_FEEC_poly_degree(b)
  return Val(r)
end

"""
    _basis_forms_components(D,k,DG_style)

If `DG_style`==true, return the triples (`I_id`, `I`, 1) for each D-dimensional
k-form components dxᴵ = dxᴵ¹ ∧ dxᴵ² ∧ ... ∧ dxᴵᵏ where `I` is a combination of
1:`D` and `I_id` = _combination_index(I), the components are ordered like in
[`_sorted_combinations`](@ref).

If `DG_style`==false, the indices are changed to implement the vector proxy of
the differential forms ω defined by:
- ω♯    if `k` = 0 or 1
- (⋆ω)♯ if `k` = `D`-1 or `D` and `k`>1
where ⋆ is the hodge star operator and ♯ the sharp map.

The triples become (`I_proxy_id`, `I`, `I_proxy_sgn`) with the same `I` (and in
the same order), such that the components of the vector proxy v of a `k`-form ω are

    v[I_proxy_id] = I_proxy_sgn * ω[I_id]

If `k` ∈ {0,1,`D`}, the triple are the same. If `k`=`D`-1, the hodge star is not
trivial so the order of the components is reversed and the signs are 1, -1, 1, -1 ...
"""
function _basis_forms_components(D,k,DG_style)
  components = Vector{Tuple{ Int, Vector{Int}, Int}}(undef, binomial(D,k))
  for (I_id, I) in enumerate(_sorted_combinations(D,k))
    if DG_style || k<2
      components[I_id] = (I_id, I, 1)
    else # if k == D, I = [1:D] and this is just (1, [], 1) (but that works)
      Icomp = _complement(I, D)
      Istar_id = _combination_index(Icomp)
      Istar_sgn = _combination_sign(I)
      components[I_id] = (Istar_id, I, Istar_sgn)
    end
  end
  components
end


################################
# PmLambdaBasis Implementation #
################################

function _generate_or_check_PmΛ_indices(r,k,D,DG_style,::Nothing)
  identity = objectid( (r,k,D,:P⁻,DG_style) )
  bubbles = PmΛ_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style)
  return PLambdaIndices(identity,bubbles,components)
end

function _generate_or_check_PmΛ_indices(r,k,D,DG_style,indices::PLambdaIndices)
  _check_PΛ_indices(r,k,D,:P⁻,DG_style,indices)
  return indices
end

function _PmΛ_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  ids = BubbleFunction[]
  for α in bernstein_terms(r-1,D)
    sup_α_ids = _sup_multi_indices(α)
    for J in _sorted_combinations(N,k+1)
      sub_J_ids = _sub_combinations_ids(J)
      j = _minimum_or_one(J)-1
      if issetequal(_support(α) ∪ J, F) && all(α[1:j] .== 0)
        w += 1
        α_id = bernstein_term_id(α)
        push!(ids, (w, α, α_id, J, sub_J_ids, sup_α_ids))
      end
    end
  end
  ids
end

"""
    PmΛ_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `PmLambdaBasis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PmΛ_bubbles(r,k,D)
      for (w, α, α_id, J, sub_J_ids, sup_α_ids) in bubble_functions
        # ...
      end
    end
"""
function PmΛ_bubbles(r,k,D)
  w=0
  bubbles = Bubble[]
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PmΛ_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k-1,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PmΛ_basis_coefficients!(m,::Val{k},D,b,vertices,indices) where k
  V = eltype(m)
  M = transpose(b.cart_to_bary_matrix[:,2:end])
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    for (I_id, I, I_sgn) in indices.components
      m_J[I_id] = I_sgn * _minor(M,I,J,Val(k))
    end
    m[J_id] = m_J
  end
  nothing
end

function _compute_PmΛ_basis_coefficients!(
  m,::Val{k},D,b,vertices::Nothing,indices) where k

  if iszero(k) # so V is scalar, no change of basis
    m .= 1
    return nothing
  end

  V = eltype(m)
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    s = Int(isone(J[1]))
    for (I_id, I, I_sgn) in indices.components
      n = count(i-> (J[i]-1)∉I, (1+s):k)
      if iszero(n)
        p = _findfirst_val_or_zero(j-> (I[j]+1)∉J, 1, k)
        m_J[I_id] = I_sgn*_minusone_if_even_else_one(p+1)
      else
        m_J[I_id] = 0
      end
    end
    m[J_id] = m_J
  end
  nothing
end

# API

function _evaluate_nd!(
  b::PmLambdaBasis{D}, x,
  ω::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  V = eltype(ω)
  λ = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,λ,Val(r-1),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, α_id, J, sub_J_ids) in bubble_functions
      Bα = cB[α_id]
      ω_w = zero(V)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        λ_j = λ[J[l]]
        m_J_l = b.m[J_sub_Jl_id]

        ω_w += flipsign(λ_j,sgnl) * m_J_l
      end

      ω[i,w] = Bα * ω_w
    end
  end
end

function _gradient_nd!(
  b::PmLambdaBasis{D}, x,
  ∇ω::AbstractMatrix{G}, i, cB,
  ∇B::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,G,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, ∇B, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, α, _, J, sub_J_ids, sup_α_ids) in bubble_functions
      ∇ω_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        α_pJl_id = sup_α_ids[Jl]

        ∇Bα_pJl = ∇B[1,α_pJl_id]
        c_α_Jl = (α[Jl]+1) * sgnl / r
        m_J_l = b.m[J_sub_Jl_id]

        ∇ω_w += (c_α_Jl * ∇Bα_pJl) ⊗ m_J_l
      end

      ∇ω[i,w] = ∇ω_w
    end
  end
end

function _hessian_nd!(
  b::PmLambdaBasis{D}, x,
  Hω::AbstractMatrix{G}, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,G,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, α, _, J, sub_J_ids, sup_α_ids) in bubble_functions
      Hω_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        α_pJl_id = sup_α_ids[Jl]

        HB_αJl = HB[1,α_pJl_id]
        c_αJl = (α[Jl]+1) * sgnl / r
        m_Jl = b.m[J_sub_Jl_id]

        Hω_w += (c_αJl * HB_αJl) ⊗ m_Jl
      end

      Hω[i,w] = Hω_w
    end
  end
end


###############################
# PLambdaBasis Implementation #
###############################

function _generate_or_check_PΛ_indices(r,k,D,DG_style,::Nothing)
  identity = objectid( (r,k,D,:P,DG_style) )
  bubbles = PΛ_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style)
  return PLambdaIndices(identity,bubbles,components)
end

function _generate_or_check_PΛ_indices(r,k,D,DG_style,indices::PLambdaIndices)
  _check_PΛ_indices(r,k,D,:P,DG_style,indices)
  return indices
end

function _PΛ_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  bubble_functions = BubbleFunction[]
  empty_vec = Int[]
  for α in bernstein_terms(r,D)
    for J in _sorted_combinations(N,k)
      j = _minimum_or_one(setdiff(F,J))-1
      if issetequal(_support(α) ∪ J, F) && all(α[1:j] .== 0)
        w += 1
        α_id = bernstein_term_id(α)
        push!(bubble_functions, (w, α, α_id, J, empty_vec, empty_vec))
      end
    end
  end
  bubble_functions
end

"""
    PΛ_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `PLambdaBasis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PΛ_bubbles(r,k,D)
      for (w, α, α_id, J) in bubble_functions
        # ...
      end
    end
"""
function PΛ_bubbles(r,k,D)
  w=0
  bubbles = Bubble[]
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PΛ_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PΛ_basis_form_coefficient!(Ψ,r,k,::Val{D},b,vertices,indices) where D
  N = D+1
  Vk = Val(k)
  V = eltype(Ψ)
  T = eltype(V)
  α_prec = ntuple(_->-1, N)
  φ_αF = MMatrix{D,N,T}(undef)
  Ψw = Mutable(V)(undef)
  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, α, _, J) in bubble_functions
      if α ≠ α_prec
        _update_φ_αF!(φ_αF,b,α,F,r)
        α_prec = α
      end

      for (I_id, I, I_sgn) in indices.components
        Ψw[I_id] = I_sgn * _minor(φ_αF,I,J,Vk)
      end
      Ψ[w] = Ψw
    end
  end
  nothing
end

@inline function _update_φ_αF!(φ_αF,b,α,F,r)
  M = b.cart_to_bary_matrix
  @inbounds for ci in CartesianIndices(φ_αF)
    i, j = ci[1], ci[2]
    mF = sum(M[Fl,i+1] for Fl in F; init=0)
    φ_αF[ci] = M[j,i+1] - α[j]*mF/r
  end
end

function _compute_PΛ_basis_form_coefficient!(
  Ψ,r,k,::Val,b,vertices::Nothing,indices)

  Vk = Val(k)
  V = eltype(Ψ)
  T = eltype(V)
  Ψw = Mutable(V)(undef)
  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, α, _, J) in bubble_functions
      for (I_id, I, I_sgn) in indices.components
        Ψw[I_id] = I_sgn * _hat_Ψ(r,Vk,α,F,I,J,T)
      end
      Ψ[w] = Ψw
    end
  end
  nothing
end

"""
    _hat_Ψ(r,::Val{k},α,F,I,J,T)::T

PLambdaBasis.Ψ matrix elements in the reference simplex, T is the scalar return type

This is actually not faster than computing the matrices and the minors
explicitely like when vertices are given, but might be usefull in case we want
to compute these at compile time one day.
"""
function _hat_Ψ(r,Vk::Val{k},α,F,I,J,::Type{T})::T where {T,k}
  @check sum(α) == r
  @check length(I) == length(J) == k

  iszero(k) && return one(T) # 0 forms

  @inbounds begin

    s = Int(isone(J[1]))
    n = count(i-> (J[i]-1)∉I, (1+s):k)

    n > 1 && return 0. # rank M_IJ inferior to 2

    p = _findfirst_val_or_zero(j-> (I[j]+1)∉J, 1, k)

    if isone(n)        # rank M_IJ is 1
      m = _findfirst_val_or_zero(i-> (J[i]-1)∉I, (s+1), k)
      u_p, v_m = _u(p,F,I), _v(m,α,J,r)
      sgn = _minusone_if_even_else_one(m+p+1)
      iszero(s) && return sgn*u_p*v_m

      q = _findfirst_val_or_zero(j-> (I[j]+s)∉J, (p+1), k)
      u_q = _u(q,F,I)
      sgn *= _minusone_if_even_else_one(q+1)
      return sgn * v_m * (u_q - u_p)
    end

    u, v = _u(F,I,Vk), _v(α,J,r,Vk)
    if iszero(s)
      return 1 + sum( u .* v )
    else
      Ψ_IJ = one(T)
      sum_v = v[1]
      for l in 1:p-1
        vlp = v[l+1]
        sum_v += vlp
        Ψ_IJ += vlp*u[l]
      end
      for l in (p+1):k
        vl = v[l]
        sum_v += vl
        Ψ_IJ += vl*u[l]
      end
      sgn = _minusone_if_even_else_one(p+1)
      return sgn * (Ψ_IJ - u[p]*sum_v)
    end

  end
  @unreachable
end

@propagate_inbounds _u(i::Int,F,I)   = Int(isone(F[1])) - Int(I[i]+1 in F)
@propagate_inbounds _u(F::Vector{Int},I,Vk) = ntuple(i->_u(i,F,I), Vk)
@propagate_inbounds _v(j::Int,α,J,r) = α[J[j]]/r
@propagate_inbounds _v(α::Vector{Int},J,r,Vk) = ntuple(j->_v(j,α,J,r), Vk)

# API

function _evaluate_nd!(
  b::PLambdaBasis{D}, x,
  ω::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  λ = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,λ,Val(r),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, α_id) in bubble_functions
      Ψw = b.Ψ[w]
      Bα = cB[α_id]
      ω[i,w] = Bα * Ψw
    end
  end
end

function _gradient_nd!(
  b::PLambdaBasis{D}, x,
  ∇ω::AbstractMatrix, i, cB,
  ∇B::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, ∇B, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, α_id) in bubble_functions
      Ψw = b.Ψ[w]
      ∇Bα = ∇B[1,α_id]
      ∇ω[i,w] = ∇Bα ⊗ Ψw
    end
  end
end

function _hessian_nd!(
  b::PLambdaBasis{D}, x,
  Hω::AbstractMatrix, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, α_id) in bubble_functions
      Ψw = b.Ψ[w]
      HBα = HB[1,α_id]
      Hω[i,w] = HBα ⊗ Ψw
    end
  end
end


########################################################
# Combination, BernsteinTerm and PLambda bases helpers #
########################################################

# A combination is a set of positive integers sorted in increasing order
# a.k.a an increasing collection of indices in a range 1:D
#     F  = 1 ≤ F1 < ... < Fd ≤ D
# It is used to represent faces of polytopes (the indices iddentifying the
# vertices of the face) or a component of a k-form as in (1,3) ~ dx¹∧dx³ .

"""
    _sorted_combinations(D,k)

Return a vector [Iᵢ]ᵢ of all the combinations of 1:`D` of length `k`:

1≤ I_1 < ... < I_k ≤ `D`

sorted in right-digit to left-digit lexicographic order, e.g.

[12, 13, 23]               for k=2, D=3
[12, 13, 23, 14, 24, 34]   for k=2, D=4

This example shows that the order of sorted combinations of same length `k` is
independant of the dimension `D`, unlike with the usual (left-digit to right-digit)
lexicographic order where 14 would be smaller than 23.

So with the chosen order, 23 is always the third length-2 combination, not the `D`ᵗʰ.
"""
function _sorted_combinations(D::Int,k::Int)
  iszero(k) &&  return Vector{Int}[ Int[] ]
  comp_rev_perm(tup) =  Int[D-tup[k-i+1]+1 for i in 1:k]
  inc_perms = combinations(1:D,k) .|> (tup -> comp_rev_perm(tup)) |> reverse
  return inc_perms
end

"""
    _combination_index(I)

Linear index of `I` amongst combinations of the same size `k`,
sorted in right-to-left lexicographic order. It depends on `k` but not on the
space dimension, see [`_sorted_combinations`](@ref).
"""
@inline function _combination_index(combi)
  k = length(combi)
  return sum( binomial(combi[i]-1, i) for i in 1:k; init=0) + 1
end

"""
    _complement(I, D)

Given a k-combination `I` of elements of 1:`D`, returns the unique `D`-k
combination of 1:D `Icomp` such that `I` ∪ `Icomp` ⊇ 1:`D`.
"""
function _complement(combi, D)
  k = length(combi)
  combi_comp = Vector{Int}(undef, D-k)
  curr_perm, curr_comp = 1, 1
  for i in 1:D
    if curr_perm ≤ k && combi[curr_perm] == i
      curr_perm += 1
    else
      combi_comp[curr_comp] = i
      curr_comp += 1
    end
  end
  combi_comp
end

"""
    _combination_sign(I)

Given a combination `I`, returns the sign of the permutation resulting from
the concatenation of `I` and its complement [`_complement(I)`](@ref _complement).
"""
function _combination_sign(combi)
  i, k, acc, delta = 1, 1, 0, 0
  while k <= length(combi)
    if combi[k] == i
      acc += delta
      k += 1
    else
      delta += 1
    end
    i += 1
  end
  return iseven(acc) ? 1 : -1
end

"""
    _sub_combinations_ids(J)

Return a vector containing the `k-1` combinations `J\\J[i]` for 1 ≤ i ≤ `k`,
where `k=length(J)`.
"""
function _sub_combinations_ids(combi)
  k = length(combi)
  sub_combi = MVector{k-1,Int}(undef)
  sub_combi_ids = Vector{Int}(undef, k)
  for i in 1:k
    sub_combi .= ntuple(j -> combi[j + Int(j≥i)],k-1)
    sub_combi_id = _combination_index(sub_combi)
    sub_combi_ids[i] = sub_combi_id
  end
  sub_combi_ids
end

"""
    _sup_multi_indices(α)

Given `α` a Bernstein term of length N, return the [`bernstein_term_id `](@ref)
of the N terms `α`+eᵢ for 1 ≤ i ≤ N in a Vector (in order of i increasing).
"""
function _sup_multi_indices(α)
  N = length(α)
  sup_α = MVector{N,Int}(undef)
  sup_α_ids = Vector{Int}(undef, N)
  for i in 1:N
    sup_α .=  ntuple(k -> α[k]+Int(k==i), N)
    sup_α_id = bernstein_term_id(sup_α)
    sup_α_ids[i] = sup_α_id
  end
  return sup_α_ids
end

"""
    _support(α)

Given a bernstein multi-index `α`, returns the set of indices `i` such that `αᵢ`>0.
"""
function _support(α)
  s = Int[]
  for (i,αi) in enumerate(α)
    if αi > 0
      push!(s, i)
    end
  end
  s
end

"""
    _minor(M,I,J,::Val{k})

Computes the minor (determinant of sub-matrix) of the matrix M where the rows of
indices i∈`I` and column of indics j∈`J` are kept. `k` is the length of both `I`
and `J`.
"""
function _minor(M,I,J,::Val{k}) where k
  @check length(I) == length(J)
  @check I ⊆ axes(M)[1]
  @check J ⊆ axes(M)[2]

  T = eltype(M)
  m = MMatrix{k,k,T,k*k}(undef)
  for (i, Ii) in enumerate(take(I,k))
    for (j, Jj) in enumerate(take(J,k))
      @inbounds m[i,j] = M[Ii,Jj]
    end
  end
  det(m)
end

@propagate_inbounds function _minusone_if_even_else_one(i)
  iseven(i) ? -1 : 1
end

@propagate_inbounds function _findfirst_val_or_zero(pred, start, stop)
  r = findfirst(pred,start:stop)
  return isnothing(r) ? 0 : r+start-1
end

@propagate_inbounds function _minimum_or_one(s)
  maxint = typemax(Int)
  j = minimum(s, init=maxint)
  j = (j==maxint) ? 1 : j
end
